\documentclass[svgnames]{report}
\usepackage[utf8]{inputenc} 
\usepackage{polski}       
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{bbm}            % sudo apt-get install texlive-fonts-recommended texlive-fonts-extra
\usepackage{amsthm}
\usepackage{algorithmic}	% sudo apt-get install texlive-science
\usepackage{listings}             % Include the listings-package
\usepackage{framed}
\usepackage{enumerate}

\makeatletter
 \renewcommand\@seccntformat[1]{\csname  the#1\endcsname.\quad}
 
 
\begin{document}
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Egzamin 2005}
\section{Część 2}
\subsection{Zadanie 5}
\begin{framed}
Udowodnij, że zbiór takich par $<G_1, G_2>$ gramatyk bezkontekstowych, dla których $L(G_1) \subseteq L(G_2)$ nie jest rekurencyjny. Wskazówka: skorzystaj z nierozstrzygalności PCP, i z tego że język słów które nie sa palidromami jest CFL.
\end{framed}

\begin{equation*}
A = \left\{ <G_1, G_2> : L(G_1) \subseteq L(G_2) \right\}
\end{equation*}

Korzystając ze wskazówki  pokażę, że: 
\begin{proof}
NIEWPROST
Załóżmy że $A -- rek \ \Leftrightarrow \ \exists_{\phi_A} \forall_x [(\phi_A(x) = 1 \Leftrightarrow x \in A) \wedge (\phi_A(x) = 0 \Leftrightarrow x \not\in A)]$.
Korzystając z powyższego założenia skonstruujemy program $phi_{PCP}$ rozpoznający przynależność do PCP.
Program będzie działać następująco:
\begin{enumerate}
	\item Wczytaj zbiór par: $P = \left\{ (l_1, r_1), \cdots, (l_k, r_k) \right\}$. Niech $\Sigma$ będzie alfabetem symboli, z których zbudowane są słowa $l_i$ oraz $r_i$ z jednym dodatkowym symbolem '\#' nie występującym w żadnym $l_i$ oraz $r_i$.
	\item Korzystając ze wskazówki niech $G_2$ będzie gramatyka generująca język słów nad alfabetem $\Sigma$, które nie są palidromami.
	\item Niech:
		\begin{equation*}
			G_1 = <\Sigma, \left\{ S \right\}, \left\{ S \rightarrow \# \right\} \cup \left\{ S \rightarrow l_i^R S r_i : 1 \geqslant i \leqslant k \right\}, S>
		\end{equation*}
	Zaóważmy, że: 
	\begin{equation*}
		L(G_1) = \left\{ t^R\#v : \exists_{w_1, \cdot w_s \in \left\{ 1, \cdots, k \right\} }t = l_{w_1} \cdots l_{w_s} \wedge v = r_{w_1} \cdot r_{w_s} \right\}
	\end{equation*}
	\item zwróć 1 jeżeli $\phi_A(<G_1, G_2>) = 0$, 0 wpp.
\end{enumerate}

Zaóważmy że powyższy program rzeczywiście rozstrzyga przynależność do PCP:
\begin{description}
	\item[$P \in PCP$]
		Wtedy istnieje taki ciąg $w_1, \cdots, w_s \in \left\{ 1, \cdots, k \right\}$, że $t = l_{w_1} \cdots l_{w_s}$, $v = r_{w_1} \cdots r_{w_s}$ i $t=v$.
		Słowo $t^R\#v$ jest palidromem i $t^R\#v \not\in A$, wiec $\phi_{PCP}(P) = \phi_A(<G_1, G_2>) = 0$
	\item[$P \not\in PCP$]		
		Wtedy nie istnieje taki ciąg by $t = v$.
		Słowo $t^R\#v$ nie jest palidrome, gdyż:
		\begin{description}
			\item[a)] jeżeli t i v są rożnej długości to symbol \# nie leży po środku,
			\item[b)] jeżeli t i v są równej długości to słowo nie jest palidromem bo $t \not= v$.
		\end{description}
		Zaóważmy, że wtedy $\forall_{t,v} t^R\#v \in A$ czyli żadne słowo generowane przez $G_1$ nie jest palidromem.
		Z powyższych rozważań wynika że: $\phi_{PCP}(P) = \phi_A(<G_1, G_2>) = 1$
\end{description}

Z powyższych rozwań wynika sprzeczność gdyż pokazaliśmy że PCP jest rek, a wiemy że tak nie jest.

\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Egzamin 2007 poprawka}
\section{Część 2}
\subsection{Zadanie 4}
\begin{framed}
Niech A będzie zbiorem takich par numerów programów $\left<n, m\right>$, że dla każdej naturalnej k albo program o numerze n uruchominy dla danej k się zatrzymuje, a program o numerze m uruchominy dla danej k się nie zatrzymuje, albo program o numerze m uruchomiony dla danej k się zatrzymuje, a program o numerze n uruchominy dla danej k się nie zatrzymuje.

Czy A jest rekurencyjnie przeliczalny?
\end{framed}

\begin{equation}
A = \left\{<n,m> : \forall_k \left[ \left( \phi_n(k) = \perp \wedge \phi_m(k) \not= \perp \right) \vee \left( \phi_n(k) \not= \perp \wedge \phi_m(k) = \perp \right) \right] \right\}
\end{equation}

Pokażemy, że A nie jest rekurencyjnie przeliczalny.

Załóżmy niewprost że:
\begin{equation}
A - r.e. \Leftrightarrow \exists_{\phi_A} \forall_{n,m} (\phi_A(<n,m>) = 1 \Leftrightarrow <n,m> \in A) \wedge (\phi_A(<n,m>) = \perp \Leftrightarrow <n,m> \not\in A)
\end{equation}

Skonstruujemy następujący program, rozpoznający przynależność do $\overline{K}$:
\begin{lstlisting}
wczytaj n
t <- numer nastepujacego programu:
	wczytaj m
	return 1
t' <- numer nastepujacego programu:
	wczutaj n
	return phi_n(n)
return phi_A(t, t')
\end{lstlisting}
Program rzeczywiście rozpoznaje przynależność do $\overline{K}$:
\begin{description}
	\item[$n \in \overline{K}$]
		\begin{equation}
			n \in \overline{K} \ \Rightarrow \ \forall_x \phi_{t'}(x) = \perp \ \Rightarrow \ \phi_A(t, t') = 1
		\end{equation}
	\item[$n \not\in \overline{K}$]
		\begin{equation}
			n \not\in \overline{K} \ \Rightarrow \ \forall_x \phi_{t'}(x) \not= \perp \ \Rightarrow \ \phi_A(t, t') = \perp
		\end{equation}
\end{description}
Tutaj mamy sprzeczność gdyż wiemy że $\overline{K}$ nie jest r.e. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Egzamin 2008}
\section{Część 2}
\subsection{Zadanie 4}
\begin{framed}
Czy istnieje algorytm rostrzygający dla danych dwóch deterministycznych automatów ze stosem, czy istnieje niepuste słowo, które zostanie zaakceptowane przez oba te automaty?

Przez deterministyczny automat ze stosem rozumiemy tu automat, którego każdy krok polega na wczytaniu jedneo symbulu ze słowa wejściowego, jednego symbolu ze stosu i w zależności od wczytanych danych oraz od aktualnego stanu, na zmianie stanu i odłożeni na stos ciągu ( być może pustego) symboli (w szczególności taki automat nie wykonue $\varepsilon$-przejść). Automat akceptuje słowo, jeśli po wczytaniu tego słowa stos jest pusty (tzn. zaiwera jedynie symbol dna stosu).
\end{framed}

Taki algorytm nieistnieje.
W celu pokazania tego, stworzymy redukcję, przedstawioną poniżej, problemu PCP (nierostrzygalnego) do naszego problemu z automatami.
\begin{equation}
f(\left<(l_1, r_1), \cdots, (l_k, r_k)\right>) = (A_1, A_2) \ \hbox{gdzie $A_1$ i $A_2$ to automat opisane w zadaniu}
\end{equation}

Automaty $A_1$ i $A_2$ zbudujemy tak by akceptoway języki opisane poniżej:
\begin{equation}
L(A_1) = L(\left\{ i_{j_1} \cdots i_{j_s} l^R_{j_s} \cdots l^R_{j_1}\right\})
\end{equation}
\begin{equation}
L(A_2) = L(\left\{ i_{j_1} \cdots i_{j_s} r^R_{j_s} \cdots r^R_{j_1}\right\})
\end{equation}

Idea automaty $A_1$:
Automat wczytuje tylke słowa postaci ciąg indeksów, po którym występuje ciąg literek, w przeciwnym przypadku zatrzymuje sie z niepustym stosem.
\begin{enumerate}
	\item automat wczytuje kolejne indeksy $i_j$ i wrzuca na stos słowa $l_{i_j}^R$
	\item gdy zobaczy literke to ściąga ją ze stosu jeżeli taka sama leży na wierzchu lub się zacina
\end{enumerate}

%Niech $\left<i_1, \cdtos, i_k\right>$ będzie zbiorem indeksów od 1 do k.

\subsection{zadanie 5}
\begin{framed}
Niech $A \subset N$ (nie jest r.e.) będzie zbiorem tych liczb naturalnych, ktore są numerami programów zatrzymujących się dla wszystkich danych. Niech $E \subset N$ (nie jest r.e.) bedzie zbiorem tych liczb naturalnych, które sa numerami programów nie zatrzymujujących się dla żadnych danych. Udowodnij, że $E \leqslant_{rek} A$.

Wskazówka: To jest łatwe zadanie. Przypomnij sobie co to jest redukjca. Pomyśl jakiego typu muszą byc argumenty redukcji, która masz zbudować i jakiego typu maja być wartości. Nie gap sie w pustą kartkę, napisz sobie równoważność, ktora ma zachodzić.
\end{framed}


\begin{equation}
A = \left\{i : \forall_x \varphi_i(x) \not= \perp \right\}
\end{equation}

\begin{equation}
E = \left\{j : \forall_x \varphi_j(x) = \perp \right\}
\end{equation}

Mamy pokazać że:
\begin{equation}
E \leqslant_{rek} A \ \Leftrightarrow (\exists_f \forall_{x \in N} x \in E \Leftrightarrow f(x) \in A)
\end{equation}

Pokażemy że istnieje takie $f$.
W tym celu stworzymy odpowiednią redukcję, której kod przedstiony jest poniżej:

Niech $b:N \rightarrow N \times N$ będzie bijekcją (np taką przekątniową $b(1) = (1,1)$, $b(2) = (1,2)$, $b(3) = (2,1)$, ...).

\begin{lstlisting}
wczytaj n
t = numer takiego programu:
	wczytaj m
	x, k = b(m)
	uruchom fi_n(x) na k krokow
		jesli fi_n(x) zatrzyma sie i zwroci wynik to zapetl sie
		w.p.p. zwroc 1
zwroc t
\end{lstlisting}

\begin{description}
	\item[$n \in E$] 
		\begin{equation*}
			n \in E \ \rightarrow \ \forall_x \varphi_n(x) = \perp \ \rightarrow \ \forall_x \varphi_t(x) = 1 \not= \perp \ \rightarrow t = f(n) \in A
		\end{equation*}
	\item[$n \not\in E$]
		\begin{equation*}
			n \not\in E \ \rightarrow \ \exists_x \varphi_n(x) \not= \perp \ \rightarrow \ \exists_m b(m)=(x,k) \wedge \varphi_n(x) \hbox{ uruchomione na k kroków} \not= \perp \ \rightarrow \exists_m \varphi_t(m) = \perp \ \rightarrow n \not\in A
		\end{equation*}
		
\end{description}
\subsection{zadanie 6}
\begin{framed}
Niech A i E będą takie, jak w poprzednim zadaniu. Czy zachodzi nierówność $A \leqslant_{rek} E$?

Wskazówka: Co pamiętasz z ćwiczeń na temat nierówności  $K \leqslant_{rek} \overline{K}$?
\end{framed}

Korzystając ze wskazówki wiemy że $K \not\leqslant_{rek} \overline{K}$.
Pokażemy, że:
\begin{equation}
K \leqslant_{rek} A \ \wedge \ E \leqslant_{rek} \overline{K} \ \Rightarrow \ A \not \leqslant_{rek} E 
\end{equation}

Najpierw pokażemy, że:
\begin{equation}
K \leqslant_{rek} A \Leftrightarrow \exists_f \forall_{x} x \in K \Leftrightarrow f(x) \in A
\end{equation}
W tym celu skonstrujemy następująca redukcje f:
\begin{lstlisting}
wczytaj n 
t <- znajdz numer nastepujacego programu:
	wczytaj m
	zwroc fi_n(n)
zwroc t
\end{lstlisting}
\begin{description}
	\item[$n \in K$] 
		\begin{equation*}
			n \in K \Rightarrow \forall_x \varphi_t(x) = \varphi_n(n) \not= \perp \Rightarrow n \in A
		\end{equation*}
	\item[$n \not\in K$]
		\begin{equation*}
			n \not\in K \Rightarrow \forall_x \varphi_t(x) = \varphi_n(n) = \perp \Rightarrow n \not\in A
		\end{equation*}
\end{description}

Teraz pokażemy, że:
\begin{equation}
E \leqslant_{rek} \overline{K} \Leftrightarrow \exists_f \forall_{x} x \in K \Leftrightarrow f(x) \in \overline{K}
\end{equation}
W tym celu skonstrujuemy następującą redukcje f:
\begin{lstlisting}
wczytaj n
t <- znajdz numer nastepujacego programu:
	wczytaj m
	dla kazdego i od 1 do ....
		dla kazdego j od 1 do ...
			jezeli fi_n(i) zwroci wyniki po j krokach zwroc 1
	zwroc 1	
zwroc t
\end{lstlisting}
\begin{description}
	\item[$n \in E$]
		\begin{equation*}
			n \in E \Rightarrow \forall_x \varphi_n(x) = \perp \Rightarrow \neq \exists_{i,j} \varphi_n(i) \hbox{ zatrzyma sie po j krokach } \Rightarrow \forall \varphi_t(x) = \perp \Rightarrow \varphi_t(t) = \perp \Rightarrow t = f(n) \in \overline{K}
		\end{equation*}
	\item[$n \not\in E$]
		\begin{equation*}
			n \not\in E \Rightarrow \exists_{i,j} \varphi_n(i) \hbox{ zatrzyma sie po j krokach } \Rightarrow \forall_x \varphi_t(x) = 1 \Rightarrow \varphi_t(t) = 1 \Rightarrow t = f(n) \not\in \overline{K}
		\end{equation*}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Egzamin 2011}
\section{Zadanie 5}
\begin{framed}
\begin{equation*}
A_0 = \left\{ \phi_n : Dom(\phi_n) = \emptyset \right\}
\end{equation*}
\begin{equation*}
A_1 = \left\{ \phi_n : |Dom(\phi_n)| = 1 \right\}
\end{equation*}

Czy $A_0 \leqslant_{REK} A_1$ ?
\end{framed}

\begin{equation*}
A_0 \leqslant_{REK} A_1 \ \Leftrightarrow \ \exists_f \forall_n n \in A_0 \Leftrightarrow f(n) \in A_1
\end{equation*}

REDUKCJA f:
\begin{lstlisting}
wczytaj n
t <- znajdz numer programu:
	wczytaj m
	if m == 1 then zwroc 1
	else zwroc phi_n(m-1)
return t
\end{lstlisting}
	

\section{Zadanie 5}
\begin{framed}
	Czy $A_1 \leqslant A_0$?
\end{framed}

Pokażemy, że:
\begin{equation}
	K \leqslant A_1 \ \wedge \ A_0 \overline{K} \ \Rightarrow \ A_1 \not\leqslant A_0
\end{equation}

1) Pokażemy, że: 
\begin{equation*}
K \leqslant A_1 \ \Leftrightarrow \ (\exists_{f_1} \forall_n n \in K \Leftrightarrow f(n) \in A_1)
\end{equation*}

REDUKCA $f_1$:
\begin{lstlisting}
wczytaj n
t <- znajdz numer programu:
	wczytaj m
	if m == 1 then
		uruchom $phi_n(n)$
	else zapetl sie
return t
\end{lstlisting}

2) Pokażemy, że:
\begin{equation*}
A_0 \leqslant \overline{K} \ \Leftrightarrow \ (\exists_{f_2} \forall_n n \in A_0 \Leftrightarrow f(n) \in \overline{K} )
\end{equation*}

REDUKCJA $f_2$:
\begin{lstlisting}
wczytaj n
t <- znajdz numer programu:
	wczytaj m
	for i=1 to +inf
		for j=1 to i
			uruchom phi_n(m) na i krokow 
			jezeli phi_n(m) zatrzyma sie i zwroci wynik to zwroc 1
return t	
\end{lstlisting}

\begin{thebibliography}{99}
\bibitem{Test} test reference
\end{thebibliography}

\end{document}



